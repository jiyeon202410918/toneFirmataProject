1. 프로젝트 목표
스위치, LED, 조도센서, 부저를 사용하여 '반짝반짝 작은별' 리듬 게임을 만드는 것이 목표였습니다. 특히 UI가 없고 하드웨어 부품만으로 구현해야 했기 때문에, 소리, 빛, 버튼 입력 간의 상호작용이 가장 중요했습니다.

2. 핵심 아이디어
게임 진행:

게임 준비: 아두이노가 켜지면 모든 LED가 한 번 점등하며 준비 상태를 알립니다.

인트로: '도, 미, 솔, 시' 음을 차례로 연주하고, 각 음에 맞는 LED가 빛나며 사용자에게 음과 빛의 관계를 알려줍니다.

게임 시작: 무작위로 3개의 음이 불규칙한 간격으로 연주되고, 해당 음에 맞는 LED가 빛납니다.

입력: 사용자는 들었던 음과 빛의 순서를 기억하고, 각 음에 맞는 버튼을 누릅니다.

게임 결과:

성공: 3개의 음을 모두 정확하게 맞추면 모든 LED가 켜지고 '반짝반짝 작은별' 노래가 연주됩니다.

실패: 중간에 한 번이라도 틀리면 모든 LED가 3번 깜빡이며 실패를 알립니다.

3. 기술적 구현 (파이썬 + 아두이노)
이 프로젝트는 파이썬을 사용하여 게임의 모든 로직을 제어하고, 아두이노는 센서와 LED, 부저를 제어하는 역할을 분담했습니다.

아두이노 역할 (C++ 코드):

Firmata 펌웨어: 아두이노가 파이썬의 명령을 이해할 수 있도록 **Firmata**라는 통신 규약을 사용합니다.

부저 제어: 특히 부저를 울리기 위해 **send_sysex**라는 커스텀 통신 방식을 사용했습니다. 이는 파이썬이 0x7E라는 특별한 명령어를 보내면, 아두이노가 이 명령어를 감지하여 tone() 함수로 소리를 내는 방식입니다. 이 방식 덕분에 부저 소리 문제를 해결할 수 있었습니다.

파이썬 역할 (.py 코드):

pyfirmata2 라이브러리: 이 라이브러리를 사용해 파이썬에서 아두이노의 각 핀을 제어합니다.

콜백(Callback): 버튼을 눌렀을 때만 코드가 실행되도록 콜백 함수를 설정했습니다. 이 방법으로 버튼 바운싱(Bouncing) 문제를 해결할 수 있었습니다.

게임 로직: 랜덤 패턴 생성, 사용자 입력 확인, 성공/실패 판정 등 게임의 모든 흐름을 파이썬 코드가 관리합니다.

4. 주요 코드 설명
1. main() 함수:
게임 전체의 흐름을 관리합니다. ready_effect(), intro_sequence(), play_game() 등 각 단계를 순서대로 호출하고, while not game_end 루프를 통해 게임이 끝날 때까지 대기합니다.

2. play_note_firmata() 함수:
부저 소리를 내는 핵심 함수입니다. 음표(예: 'C4')와 박자를 인자로 받아, 주파수와 지속 시간을 7비트 데이터로 인코딩한 뒤, board.send_sysex()로 아두이노에 전송합니다.

3. on_button_press() 함수:
버튼이 눌릴 때마다 자동으로 실행됩니다.

last_button_press_time 변수를 이용해 디바운싱을 처리합니다.

눌린 버튼이 무작위로 생성된 **random_sequence**와 일치하는지 확인합니다.

정답이면 user_sequence_index를 증가시키고, 오답이면 failure_effect()를 호출합니다.

4. success_effect() / failure_effect() 함수:
게임의 결과를 보여줍니다. success_effect()는 '반짝반짝 작은별'을 연주하고, failure_effect()는 for 루프를 통해 LED를 여러 번 깜빡입니다.
